# SPEC_PATCH.md
# APPLIES TO: SCHEMA.md, API_CONTRACT.md

## [NEW – REQUIRED ADDITION] Push Token Storage (SCHEMA.md)
FILE: SCHEMA.md
LOCATION: Section B.1 (users table) OR New Table

Add the following field to the `users` table or create a `user_devices` table. For v0.1 simplicity, adding to `users` is acceptable if single-device assumption holds, but `user_devices` is safer.

**Update `users` table in SCHEMA.md (B.1):**
| Column | Type | Nullable | Default | Notes |
| push_token | VARCHAR(256) | NULL | - | Push Token for Retention |

**Update Prisma Model (User):**
model User {
  ...
  pushToken String? @map("push_token") @db.VarChar(256)
  ...
}

## [NEW – REQUIRED ADDITION] Device Registration Endpoint (API_CONTRACT.md)
FILE: API_CONTRACT.md
LOCATION: Section 4 (Settings DTOs)

Add endpoint to register the push token.

**Endpoint:** `POST /user/device`
**Interface:**
```typescript
export interface RegisterDeviceDto {
  push_token: string; // Push notification token
  platform: 'ios' | 'android';
}

[NEW – REQUIRED ADDITION] Account Deletion (API_CONTRACT.md)
FILE: API_CONTRACT.md LOCATION: Section 5 (Standard Plumbing)

Endpoint: DELETE /user/me Purpose: Hard delete of user and all data. Interface:
// No body required.
// Returns 200 OK on success.

## [NEW – CORRECTION] Chat Turn Persistence Model (AI_PIPELINE.md)
FILE: AI_PIPELINE.md
LOCATION: Section 4.1 API ingress (chat turn) - Step 6 & 7 Replace

**Replace the "Writeback" logic in Step 6j and Step 7 with:**

j. Transaction BEGIN:
   - **INSERT** new `messages` row for Assistant Response:
     - `id`: generate new UUID
     - `role`: 'assistant'
     - `content`: final_response
     - `status`: COMPLETED
     - `surfaced_memory_ids`: [list]
     - `trace_id`: same as user message trace_id
   - RelationshipService.update(delta)
   - MemoryService.extractAndPersist(user_text)
   - COMMIT
k. QueueService.enqueue('embedding', { memory_ids })

7) Return `assistant_message` object (id, content, created_at) to client.

## [NEW – ADDITION] Worker Workspace Setup (MONOREPO_SETUP.md)
FILE: MONOREPO_SETUP.md
LOCATION: Section 1 (Directory Structure) and Section 2 (Init Script)

**Add `apps/workers` to the directory structure:**
```text
apps/
├── api/
├── mobile/
└── workers/          # BullMQ Processors (NestJS Standalone Context)
    ├── src/
    ├── package.json  # Depends on "@chingoo/shared"
    └── tsconfig.json

## [NEW – CLARIFICATION] Canonical API Terminology (ARCHITECTURE.md)
FILE: ARCHITECTURE.md
LOCATION: Section C.0 (Intro)

**Insert Warning:**
> **STRICT TERMINOLOGY:** If variable names in this document differ from `API_CONTRACT.md`, `API_CONTRACT.md` is the **Canonical Source of Truth**.
> - Use `user_message` (not `text`).
> - Use `local_timestamp` (not `local_sent_at`).

## [NEW – ADDITION] Standard Error DTOs (API_CONTRACT.md)
FILE: API_CONTRACT.md
LOCATION: Section 5 (Standard Plumbing)

**Add General Error Interface:**

```typescript
export interface ApiErrorDto {
  statusCode: number;
  message: string;
  error: string;
  // Included only for validation errors (400)
  constraints?: string[]; 
}

Explicit Status Codes:

400 Bad Request: Validation failed (e.g., missing fields in Onboarding).

401 Unauthorized: Invalid or missing Auth Token.

403 Forbidden: User state is CREATED (accessing chat) or Safety Ban.

409 Conflict: Idempotency key collision (if handled as error) or unique constraint violation.

## [NEW – EXCEPTION] JavaScript Configuration Files (VERSIONS.md)
FILE: VERSIONS.md
LOCATION: Section 5 (Forbidden List)

**Update Point 4:**
4. **NO JavaScript source files:** All application logic must be strict TypeScript (`.ts` / `.tsx`).
   - **EXCEPTION:** Configuration files required by tools (e.g., `metro.config.js`, `babel.config.js`, `eslint.config.js`) MAY be JavaScript if the tool does not support TS natively or if TS config causes circular compilation issues.

[NEW – REQUIRED ADDITION]

FILE: AI_PIPELINE.md
LOCATION: 2.1 TurnPacket (normalized incoming turn) → append to field list
- `trace_id` (uuid) — generated by server at ingress per request/turn.
  - MUST be stable for all writes performed for that turn (messages, decision trace, memory writes).
  - Used to correlate the user message row and assistant message row for idempotency replay and audit.

[NEW – REQUIRED ADDITION]

FILE: AI_PIPELINE.md
LOCATION: 4.1 Idempotency → append a “Replay” subsection
### 4.1.X Replay Semantics (Contract-Locked)

If a turn arrives with an existing `message_id`:

- If the existing user message row is `COMPLETED`, return the **previously persisted assistant reply** for that turn.
- If the existing user message row is `RECEIVED` or `PROCESSING`, do not re-run the pipeline. Return a deterministic “in-progress” response (see API_CONTRACT.md Error / Refusal Semantics).
- A `message_id` MUST NOT produce more than one assistant message.


[NEW – REQUIRED ADDITION]
FILE: ARCHITECTURE.md
LOCATION: C.0 API Wire Contracts (HTTP JSON) → immediately after the /auth/signup block
> v0.1 NOTE (Hard Rule):
> `/auth/signup` is NOT implemented as a separate endpoint in v0.1.
> Authentication uses API_CONTRACT.md `POST /auth/login (or Signup)` with `AuthRequestDto { identity_token, email? }`.
> If this document shows `/auth/signup`, it must be treated as legacy/non-authoritative.

[NEW – REQUIRED ADDITION]
ILE: API_CONTRACT.md
LOCATION: Chat DTOs (POST /chat/send) → append after ChatSendResponseDto
### POST /chat/send — Idempotency Replay Semantics (v0.1)

Given `ChatRequestDto.message_id`:

1) If this `message_id` has already been processed to completion:
- Return HTTP 200
- Return the **same** `assistant_message` content and id that was persisted previously.

2) If this `message_id` exists but is not completed (server previously accepted it and is still processing):
- Return HTTP 409
- Response body: `ChatSendResponseDto` with `assistant_message.content` set to a deterministic "request in progress, retry" message.
- Server MUST NOT enqueue a second pipeline execution.

[NEW – CLARIFICATION]
FILE: API_CONTRACT.md
LOCATION: ChatRequestDto → append below local_timestamp
**Storage rule (v0.1):**
`local_timestamp` is used only for telemetry/heuristics and is NOT persisted in Postgres in v0.1.
If provided, it may be logged in structured logs keyed by `message_id`.

